# -*- coding: utf-8 -*-
"""Data-format

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c6zX4GNRbkOyznUC5vbyy4Fd0pL0NXFS

___


___
# **Olympic Champions Predictor**
"""

from google.colab import drive
drive.mount('/content/drive')

"""# Load and Inspect the Data

---
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

teams = pd.read_excel('/content/drive/MyDrive/codedex-hackathon/Teams.xlsx')
medals = pd.read_excel('/content/drive/MyDrive/codedex-hackathon/Medals.xlsx')
athletes = pd.read_excel('/content/drive/MyDrive/codedex-hackathon/Athletes.xlsx')
coaches = pd.read_excel('/content/drive/MyDrive/codedex-hackathon/Coaches.xlsx')

teams.head()

# Check how many teams participate for each country
country_counts = teams['country'].value_counts().reset_index()
print(country_counts)
country_counts.columns = ['country', 'team_count']

merged_data = pd.merge(medals, country_counts, on='country', how= "left")
merged_data.shape
# merged_data.isna().sum()

# Check how many teams participate for each country
athletes_counts = athletes['country'].value_counts().reset_index()
print(athletes_counts)
athletes_counts.columns = ['country', 'athletes_count']

merged_data = pd.merge(merged_data, athletes_counts, on='country', how ="left")
# merged_data.head()
merged_data.shape

"""** Coaches **"""

# Check how many teams participate for each country
coaches_counts = coaches['NOC'].value_counts().reset_index()
coaches_counts.columns = ['country', 'coaches_count']

merged_data = pd.merge(merged_data, coaches_counts, on='country', how ="left")
merged_data.shape

"""**GDP dataset**"""

gdp = pd.read_csv('/content/drive/MyDrive/codedex-hackathon/gdp.csv')
gdp.head()
# gdp.shape

gdp_subset = gdp[['country', 'gdpPerCapita', 'imfGDP']]

# Define a dictionary to map old country names to new names
country_name_mapping = {
    'United States': 'United States of America',
    'Mexico': "People's Republic of China",
    'United Kingdom':'Great Britain',
    'North Korea':'Republic of Korea',
    'Iran':'Islamic Republic of Iran'
}

# Drop rows where country is 'ROC' or "Côte d'Ivoire'
countries_to_drop = ['ROC', "Côte d'Ivoire"]
gdp_subset = gdp[~gdp['country'].isin(countries_to_drop)]

# Change names of countries in gdp_subset DataFrame using the dictionary
gdp_subset['country'] = gdp_subset['country'].replace(country_name_mapping)

# Display updated gdp_subset DataFrame
print("\nUpdated gdp_subset DataFrame:")
print(gdp_subset)

merged_data = pd.merge(merged_data, gdp_subset, on='country', how='left')
merged_data.shape

# Calculate total population
merged_data['total_population'] = merged_data['imfGDP'] / merged_data['gdpPerCapita']
merged_data.head()

new_column_names = {
    'Gold': 'gold',
    'Silver': 'silver',
    'Bronze': 'bronze',
    'Total': 'total',
    'team_count': 'team_count',
    'athletes_count': 'athletes_count',
    'coaches_count': 'coaches_count',
    'Rank by Total': 'rank_total',
    'Rank': 'rank',
    'imfGDP': 'gdp',
}
# Rename columns
df = merged_data.rename(columns=new_column_names)
df.head(10)

"""# Exploratory Data Analysis

---

**Exploring Number of Athletes**
"""

# Set style
sns.set_style('whitegrid')

# Filter the top 40 countries by athletes_count
df_top40 = df.sort_values('athletes_count', ascending=False).head(40)

# Set the figure size
plt.figure(figsize=(12, 6))

# Order countries by athletes_count in decreasing order within the top 40
order = df_top40['country']

# Create the bar plot with the top 40 countries
sns.barplot(data=df_top40, x='country', y='athletes_count', order=order, palette='Purples_d')

# Customize labels and title
plt.xlabel('Countries', fontsize=12)
plt.ylabel('Number of Athletes', fontsize=12)
plt.title('Number of Athletes per Country (Top 40)', fontsize=14, pad=10)
plt.xticks(rotation=90)

# Ensure all elements fit into the figure area
plt.tight_layout()

plt.show()

"""**Exploring Total Medal Count**"""

# Filter the top 40 countries by total medals
df_top40 = df.sort_values('total', ascending=False).head(40)

# Set the figure size
plt.figure(figsize=(12, 6))

# Order countries by total medals in decreasing order within the top 40
order = df_top40['country']

# Create the bar plot with total amount of medals for the top 40 countries
sns.barplot(data=df_top40, x='country', y='total', order=order, palette='Purples_d')

# Customize labels and title
plt.xlabel('Countries', fontsize=12)
plt.ylabel('Total Amount of Medals', fontsize=12)
plt.title('Number of Total Medals per Country (Top 40)', fontsize=14, pad=10)
plt.xticks(rotation=90)

# Ensure all elements fit into the figure area
plt.tight_layout()

plt.show()

"""**Exploring the Relationship between Total Medal Count and Number of Athletes**

Results: Countries having higher amounts of athletes tend to win more medals
"""

# Set the figure size
plt.figure(figsize=(12, 6))

# Set the purple color palette
colors = sns.color_palette("Purples", 2)

# Create the bar plot with total amount of medals for the top 40 countries
ax1 = sns.barplot(data=df_top40, x='country', y='total', color=colors[0])

# Customize labels and title for the bar plot
ax1.set_xlabel('Countries', fontsize=12)
ax1.set_ylabel('Total Amount of Medals', fontsize=12)
ax1.set_title('Leading 40 Countries Based on Total Medals with Athlete Participation', fontsize=14, pad=10)
ax1.set_xticklabels(df_top40['country'], rotation=90)

# Set y-axis limit for ax1 (bar plot)
ax1.set_ylim(0, df_top40['total'].max() * 1.1)  # Adjust multiplier as needed

# Create a secondary y-axis for the line plot
ax2 = ax1.twinx()

# Plot the line graph for number of participants per country
ax2.plot(df_top40['country'], df_top40['athletes_count'], marker='o', color=colors[1], linewidth=2, label='Number of Athletes')

# Customize labels and title for the line plot
ax2.set_ylabel('Number of Athletes', fontsize=12)

# Set y-axis limit for ax2 (line plot)
ax2.set_ylim(0, df_top40['athletes_count'].max() * 1.1)  # Adjust multiplier as needed

# Add a legend for the line plot on the right
ax2.legend(loc='upper right')

# Ensure all elements fit into the figure area
plt.tight_layout()

# Set the background to be transparent
plt.gcf().set_facecolor('none')
plt.grid(False)

# Save the plot with transparent background
plt.savefig('plot.png', transparent=True)
plt.show()

"""**Checking for Collinearity in DataFrame**

Strong collinearity is denoted by number close to 1 or -1.
Values approaching 0 are considered not corrolated.

Result of graph:
- team count, athletes count, coaches count, gdp are features that are highly correlated to gold, silver and bronze medals
"""

# Select only numeric columns
numeric_data = df[['gold', 'silver', 'bronze', 'team_count', 'athletes_count', 'coaches_count', 'gdp', 'gdpPerCapita', 'total_population']]

# Calculate the correlation matrix
correlation_matrix = numeric_data.corr()

# Display the correlation matrix
print(correlation_matrix)

plt.figure(figsize=(8, 6))

heatmap = sns.heatmap(correlation_matrix, annot=True, cmap='BuPu', fmt='.2f', annot_kws={'size': 10})

# Set title with larger font size
heatmap.set_title('Correlation Analysis of Features', fontsize=16)

plt.yticks(rotation=0)

plt.xticks(fontsize=12)
plt.yticks(fontsize=12)

# Ensure full visibility of y-axis labels
plt.ylim(len(correlation_matrix), 0)

# Adjust whitespace around the heatmap
plt.tight_layout()

# Show the plot
plt.show()

"""**Dealing with Missing Data**

No missing data
"""

missing_values = df[['gold', 'silver', 'bronze', 'team_count', 'athletes_count', 'coaches_count', 'gdp']].isna().sum()
print(missing_values)

df.info()

"""**Coaches count**

 Must be dropped as it is missing 42% of its data (100*39 / 93).

 **Teams count**

 Must perform data engineering as it is missing 20% of its data (100*19 / 93).
"""

# Replace None values in the 'team_count' column with -999 as it is an outlier it will be detected as such
df['team_count'] = df['team_count'].fillna(-999)

"""**GDP values**

Since there are only a few instances, we can take the mean value.
"""

# Replace None values in the 'team_count' column with -999 as it is an outlier it will be detected as such
df['gdp'] = df['gdp'].fillna(df['gdp'].mean())

"""# Best ML Model for Medal Predictions

---

After testing different models like Neural Networks and Random Forest with grid search, it was discovered that Gradient Boosting Regressor significantly
increase the predictions' accuracy.

**Gradient Boosting Regressor**
"""

# Prepare features and target
features = df[['team_count', 'athletes_count', 'gdp']]
target = df[['gold', 'silver', 'bronze']]

from sklearn.model_selection import train_test_split
from sklearn.multioutput import MultiOutputRegressor
from sklearn.ensemble import GradientBoostingRegressor

# No change in the train-test split, keep 30% for testing
X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=0.3, random_state=101)

# Define parameter grid
params = {'n_estimators': 5000, 'max_depth': 4, 'min_samples_split': 2, 'min_samples_leaf': 2}

# Initialize the model
gbm_model = MultiOutputRegressor(GradientBoostingRegressor(**params))

# Train the model on the entire training set X_train and y_train
gbm_model.fit(X_train, y_train)

# Predictions on the test set
gbm_test_predictions = gbm_model.predict(X_test)

"""**Assessing Performance and Generalizability**

Mean Performance:
- The Cross-Validation Mean MAE of ~3.092 suggests that, on average, the predictions made by this model are off by about ~3 medals (small number).

Performance Consistency:
- The high standard deviation (~2.910) indicates that there is significant variability in the model's performance across different folds. This suggests that the model may be sensitive to the specific training data it receives, indicating potential instability. This number was worse for the Random Forest model.

"""

from sklearn.model_selection import cross_val_score

# Assuming gbm_model is your trained model and features, target are defined
scores = cross_val_score(gbm_model, features, target, scoring="neg_mean_absolute_error", cv=5)
mean_score = -scores.mean()
std_score = scores.std()

print(f"Cross-Validation Mean MAE: {mean_score}")
print(f"Cross-Validation Standard Deviation: {std_score}")

'''Further Performance Metrics'''
from sklearn.metrics import mean_squared_error

# Calculate MAE for test data
mae_test_gold = mean_absolute_error(y_test['gold'], gbm_test_predictions[:, 0])
mae_test_silver = mean_absolute_error(y_test['silver'], gbm_test_predictions[:, 1])
mae_test_bronze = mean_absolute_error(y_test['bronze'], gbm_test_predictions[:, 2])

# Print the results
print(f"Mean Absolute Error for Gold Medals: {mae_test_gold}")
print(f"Mean Absolute Error for Silver Medals: {mae_test_silver}")
print(f"Mean Absolute Error for Bronze Medals: {mae_test_bronze}")
print()

# Calculate RMSE for test data
rmse_test_gold = np.sqrt(mean_squared_error(y_test['gold'], gbm_test_predictions[:, 0]))
rmse_test_silver = np.sqrt(mean_squared_error(y_test['silver'], gbm_test_predictions[:, 1]))
rmse_test_bronze = np.sqrt(mean_squared_error(y_test['bronze'], gbm_test_predictions[:, 2]))

# Print the results
print(f"Root Mean Squared Error for Gold Medals: {rmse_test_gold}")
print(f"Root Mean Squared Error for Silver Medals: {rmse_test_silver}")
print(f"Root Mean Squared Error for Bronze Medals: {rmse_test_bronze}")

"""**Store Predictions in File**"""

# Create a DataFrame with the country names and predictions
country_names = df.iloc[X_test.index]['country'].reset_index(drop=True)
predictions_df = pd.DataFrame(gbm_test_predictions, columns=['predicted_gold', 'predicted_silver', 'predicted_bronze'])
result_df = pd.concat([country_names, predictions_df], axis=1)

# Save the DataFrame to a CSV file
file_path = '/content/drive/MyDrive/codedex-hackathon/predicted_medals.csv'
result_df.to_csv(file_path, index=False)

print("Predicted medal counts have been saved to predicted_medals.csv")

"""**Calculate Ranks**

---

2 Methods:
1. Calculate ranks based on total medals, meaning weights of 1 for all three medals
2. Calculate ranks based on exponential weighted point system (4:2:1) — gold 4 points, silver 2 points, and bronze 1 point
"""

'''Method 1: Rank Based on Total Medals'''

# Calculate total predicted medals
result_df['total_medals'] = result_df['predicted_gold'] + result_df['predicted_silver'] + result_df['predicted_bronze']

# Rank countries based on total medals
result_df['rank_by_medals'] = result_df['total_medals'].rank(method='min', ascending=False)

# Sort by rank for clarity
result_df.sort_values(by='rank_by_medals', inplace=True)

# Display the results with country, rank, and total medals
print("Ranking based on Total Medals:")
print(result_df[['country', 'rank_by_medals', 'total_medals']])

# Calculate weighted points based on the 4:2:1 system
result_df['weighted_points'] = 4 * result_df['predicted_gold'] + 2 * result_df['predicted_silver'] + 1 * result_df['predicted_bronze']

# Rank countries based on weighted points
result_df['rank_by_points'] = result_df['weighted_points'].rank(method='min', ascending=False)

# Sort by rank for clarity
result_df.sort_values(by='rank_by_points', inplace=True)

# Display the results
print("Ranking based on Weighted Points (4:2:1 system):")
print(result_df[['country', 'rank_by_points','weighted_points']])

